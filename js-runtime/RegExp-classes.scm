(module jsre-RegExp-classes
   (export
    (RegExp-class-condition char/class
			    case-sensitive?)
    (inline RegExp-match-c c class)))

;; TODO: classes should have precomputed ranges for white-space...
;       ((:any) (not (char=? c #\newline)))
;       ;
;       ((:alnum) (or (char-alphabetic? c) (char-numeric? c)))
;       ((:alpha) (char-alphabetic? c))
;       ((:ascii) (< (char->integer c) 128))
;       ((:blank) (or (char=? c #\space) (char=? c *pregexp-tab-char*)))
;       ((:cntrl) (< (char->integer c) 32))
;       ((:digit) (char-numeric? c))
;       ((:graph) (and (>= (char->integer c) 32)
;                      (not (char-whitespace? c))))
;       ((:lower) (char-lower-case? c))
;       ((:print) (>= (char->integer c) 32))
;       ((:punct) (and (>= (char->integer c) 32)
;                      (not (char-whitespace? c))
;                      (not (char-alphabetic? c))
;                      (not (char-numeric? c))))
;       ((:space) (char-whitespace? c))
;       ((:upper) (char-upper-case? c))
;       ((:word) (or (char-alphabetic? c)
;                    (char-numeric? c)
;                    (char=? c #\_)))
;       ((:xdigit) (or (char-numeric? c)
;                      (char-ci=? c #\a) (char-ci=? c #\b)
;                      (char-ci=? c #\c) (char-ci=? c #\d)
;                      (char-ci=? c #\e) (char-ci=? c #\f)))

(define-inline (RegExp-match-c c class)
   (let ((cn (char->integer c)))
      (if (< cn 64)
	  (let ((l (vector-ref class 0)) ;; lower
		(mask (make-llong (bit-lsh 1 cn))))
	     (not (=llong #l0 (bit-andllong l mask))))
	  (let ((u (vector-ref class 1)) ;; upper
		(mask (make-llong (bit-lsh 1 (-fx cn 64)))))
	     (not (=llong #l0 (bit-andllong u mask)))))))
	  
;; For now just build a range based on ASCII chars.
(define (RegExp-class-condition char/class case-sensitive?)
   (define (char-field-n cn)
      (if (< cn 64)
	  (values (make-llong (bit-lsh 1 cn))
		  #l0)
	  (values #l0
		  (make-llong (bit-lsh 1 (- cn 64))))))

   (define (char-field c)
      (if case-sensitive?
	  (char-field-n (char->integer c))
	  ;; HACK: case-sensitivity.
	  (receive (l u)
	     (char-field-n (char->integer (char-downcase c)))
	     (receive (l2 u2)
		(char-field-n (char->integer (char-upcase c)))
		(values (bit-orllong l l2)
			(bit-orllong u u2))))))
      
   (define (range-field from to)
      (let loop ((from from)
		 (lower #l0)
		 (upper #l0))
	 (if (>= from to)
	     (values lower upper)
	     (receive (l u)
		(char-field (integer->char from))
		(loop (+fx from 1)
		      (bit-orllong l lower)
		      (bit-orllong u upper))))))

   (define (chars-field chars)
      (let loop ((chars chars)
		 (lower #l0)
		 (upper #l0))
	 (if (null? chars)
	     (values lower upper)
	     (receive (l u)
		(char-field (car chars))
		(loop (cdr chars)
		      (bit-orllong lower l)
		      (bit-orllong upper u))))))

   (define (digits-field)
      (range-field #\0 #\9))

   (define (white-field)
      (chars-field '(#x09 #x0B #x0C #x20 #xA0)))

   (define (any-field)
      (chars-field '(#xA #xD #x2028 #x2029)))

   (define (word-field)
      (receive (l u)
	 (range-field #\a #\z)
	 (receive (l1 u1)
	    (range-field #\A #\Z)
	    (receive (l2 u2)
	       (range-field #\0 #\9)
	       (receive (l3 u3)
		  (char-field #\_)
		  (values (bit-orllong (bit-orllong l (bit-orllong l1 l2)) l3)
			  (bit-orllong (bit-orllong u (bit-orllong u1 u2)) u3)))))))

   (define (xdigits-field)
      (receive (l u)
	 (range-field #\0 #\9)
	 (receive (l2 u2)
	    (range-field #\a #\f)
	    (receive (l3 u3)
	       (range-field #\A #\F)
	       (values (bit-orllong (bit-orllong l l2) l3)
		       (bit-orllong (bit-orllong u u2) u3))))))

   (define (inverted f)
      (receive (l u)
	 (f)
	 (values (bit-notllong l)
		 (bit-notllong u))))


   (define (bit-field char/class)
      (match-case char/class
	 ((and (? char?) ?c)
	  (char-field c))
	 ((:range ?from ?to)
	  (range-field from to))
	 ((:char-range ?from ?to)
	  (range-field (char->integer from) (char->integer to)))
	 ((:any)
	  (any-field))
	 ((:digit)
	  (digits-field))
	 ((:not-digit)
	  (inverted digits-field))
	 ((:space)
	  (white-field))
	 ((:not-space)
	  (inverted white-field))
	 ((:word)
	  (word-field))
	 ((:not-word)
	  (inverted word-field))
	 ((:xdigit)
	  (xdigits-field))
	 ((:not-xdigit)
	  (inverted xdigits-field))
	 ((:neg-char ?inverted-char/class)
	  (receive (lower upper)
	     (bit-field inverted-char/class)
	     (values (bit-notllong lower))
		     (bit-notllong upper)))
	 ((:one-of-chars . ?chars/classes)
	  (let loop ((cs/cs chars/classes)
		     (lower #l0)
		     (upper #l0))
	     (if (null? cs/cs)
		 (values lower upper)
		 (let ((c/c (car cs/cs)))
		    (receive (l u)
		       (bit-field c/c)
		       (loop (cdr cs/cs)
			     (bit-orllong lower l)
			     (bit-orllong upper u)))))))
	 (else
	  (error "RegExp Class"
		 "forgot character class"
		 char/class))))

   (define (nb-chars lower upper)
      (define (nb-bits i::llong res::bint)
	 (if (= i 0)
	     res
	     (nb-bits (bit-andllong (- i 1) i)
		      (+fx res 1))))

      (+ (nb-bits lower 0) (nb-bits upper 0)))

   (define (get-single-char lower upper)
      (define (get-bit-pos i::llong)
	 (let loop ((j 1)
		    (k (make-llong 1)))
	    (if (not (= 0 (bit-andllong i k)))
		j
		(loop (+ j 1) (*llong k 2)))))

      (if (=llong lower 0)
	  (integer->char (+ 64 (get-bit-pos upper)))
	  (integer->char (get-bit-pos lower))))
	  
   (receive (lower upper)
      (bit-field char/class)
      (if (= (nb-chars lower upper) 1)
	  (get-single-char lower upper)
	  (vector lower upper))))
